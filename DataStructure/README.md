1.時間復雜度
   Tips:
   (1) O(x):X爲計算次數中最大次方數，如O(1),O(n),O(n**2)...
   (2 常見時間復雜度（按效率排序）
       O(1)<O(logn)<O(n)<O(nlogn)<O(n**2)<O(n**2logn)<O(n**3)
   (3) 復雜問題時間復雜度
       O(n!),O(2**n),O(n**n)
   快速判斷時間復雜度（適用多數）：
   (1) 當算法過程中出現循環折半的時候，復雜度式子中會出現logn.
   (2) K曾循環爲n**k

2.空間復雜度
   評估算法內存佔用大小的式子
   Tips:
   (1) 算法使用了幾個變量：O（1）
   (2) 使用了長度爲n的一維列表：O(n)
   (3) 使用了m行n列的二維列表：O(mn)

3. 遞歸
  兩個特點：調用自身，結束條件
  例：hanoi.py
     汗诺塔移动次数的递推式：h(x)=2h(x-1)+1

4. 查找 search.py
4.1 顺序查找 linear_search 线性查找
    时间复杂度： O(n)
4.2 二分查找 bin_search 数据需先排序
    时间复杂度： O（logn)
Tips:Python 内置函数 index()为线性查找，因为它无法确认输入数据是否有序。

5. 列表排序 sort
   常见排序算法
   low :冒泡排序， 选择排序， 插入排序 Tips：原地排序
   NB：快速排序， 堆排序， 归并排序
   other:希尔排序， 计数排序， 基数排序
5.1 冒泡排序 Bubble Sort
  代码关键点：派了几趟，无序区范围
  时间复杂度：O（n**2)
  性能提升：若一趟中无数据交换，认为已全部排好顺序,添加标识位exchange
5.2 选择排序 select sort
  代码关键点：有序区，无序区和无序区最小数的位置
  时间复杂度：O（n**2)
5.3 插入排序 insert sort
  时间复杂度：O（n**2)
  代码关键点：插入的位置

5.4 快速排序 quick sort
   时间复杂度：O(nlogn)
   问题：最坏的情况时间复杂度为O（n**2)，含有递归过程
   尽量避免最坏情况：随机选取一个数作为第一个数
5.5 堆排序
  5.5.1 树
  1）二叉树
     度不超过2的树（即每个节点最多有两个孩子节点）
  2）满二叉树
     一个二叉树，如果每一层的结点数都达到最大值，则这个二叉树就是满二叉树。
  3）完全二叉树
     叶子结点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树

  二叉树的存储方式：顺序存储，链式存储
  1）顺序存储
     父节点和左孩子结点的编号下标关系：i -> 2i+1  i为父节点
     父节点和右孩子结点的编号下标关系：i -> 2i+2  i为父节点
     孩子结点和父节点的编号下标关系：i ->（i-1）//2 i为子节点
  5.5.2 堆 heap sort
   一种特殊的完全二叉树结构
   大根堆：一颗完全二叉树，满足任一节点都比其孩子节点大
   小根堆：一颗完全二叉树，满足任一节点都比其孩子节点小
   1）堆的向下调整  sift
      当根节点的左右子树都是堆时，根本身不满足堆性质，可以通过一次向下的调整来将其变换成一个堆。


